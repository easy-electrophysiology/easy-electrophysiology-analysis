"""
Copyright Â© Joseph John Ziminski 2020-2021.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import neo
import numpy as np
from PySide2.QtWidgets import QInputDialog, QMessageBox
from utils import fonts_and_brushes
from utils import utils
from ephys_data_methods import core_analysis_methods

# ----------------------------------------------------------------------------------------------------------------------------------------------------
# Load Data With Neo
# ----------------------------------------------------------------------------------------------------------------------------------------------------
# Methods for loading in data. Generates a "Data" class that contains Vm, Im, and Time data.
# Uses the neo electrophysiology module. Handles 1, 2 or more channels (but forces user to input 2 channels
# when there are > 2. The main method "import_data" will return None if import fails.
# ----------------------------------------------------------------------------------------------------------------------------------------------------

def import_data(full_filepath, file_ext, cfgs):
    """
    Import data using Neo and output a structure containing channel information and data.
    Currently only 2 channels are supported, if more are in the file let the user select.
    Converts units to mV, ms and pA.

    INPUTS:
        full_filepath: The full filepath to the data to load (including the ext on end)
        file_ext: The extension of the file (seperate for convenience)
        cfgs: config file

    OUTPUT:
        DataModel file including data arrays and file / data information.
    """

    # Load with neo and get primary and secondary channel index
    channels, reader, block_neo_file = load_file_with_neo(full_filepath, file_ext)
    if channels is None:
        return None

    channel_1, channel_1_idx, channel_2, channel_2_idx = get_channel_data_info(cfgs, channels, reader)
    if channel_1 is None or channel_is_proxy(channel_1_idx, block_neo_file, channel_1=True):
        return None

    # Get channel type (Im or Vm), units and load data structure
    channel_1_type, channel_1_units = get_channel_type(channel_1, cfgs)
    if not channel_1_type:
        return False

    if channel_2 and not channel_is_proxy(channel_2_idx,
                                          block_neo_file):
        channel_2_type, channel_2_units = get_channel_type(channel_2,
                                                           cfgs)
        if not channel_2_exists_and_is_different_type_to_channel_1(channel_1_type,
                                                                   channel_2_type):
            return False

        Data = ImportData(block_neo_file, 2, cfgs,
                          channel_1_type, channel_1_units, channel_1_idx,
                          channel_2_type, channel_2_units, channel_2_idx)
    else:
        Data = ImportData(block_neo_file, 1, cfgs,
                          channel_1_type, channel_1_units, channel_1_idx,
                          None, None, None)
    return Data


def channel_is_proxy(channel_idx, block_neo_file, channel_1=False):
    """
    For some filetypes (possibly just .abf generated by IGOR) self._raw_signals is shorter ('igor_abf_too_many_channels.abf in test_data')
    than the nubmer of channels neo can find. In this instance neo will fill with a proxy analogsignals
    but this will crash data loading class. Here check if any are proxy (abence of data i.e. 'manitude attribute)
    and inform the user that this channel does not exist.

    Show error message if channel 1 index is tested (if another channel fails, jsut channel 1 willl be loaded)
    TODO: confirm filetypes this works on, contact neo
    """
    channel_is_proxy = not hasattr(block_neo_file.segments[0].analogsignals[channel_idx], 'magnitude')

    if channel_1 and channel_is_proxy:
        utils.show_messagebox("Load File Error",
                              "Please ensure the data channel exists in the file. "
                              "Please contact support@easyelectrophysiology.com if this channel definitely exists.")
    return channel_is_proxy

def channel_2_exists_and_is_different_type_to_channel_1(channel_1_type, channel_2_type):
    if not channel_2_type:
        return False

    if channel_1_type == channel_2_type:
        utils.show_messagebox("Load File Error",
                              "Cannot have two channels of the same data type (e.g. voltage, voltage). "
                              "Please load only one of the channels (File > File Loading Options > Select Channels to Load).")
        return False
    return True

def load_file_with_neo(full_filepath, file_ext):
    """
    Load the file with Neo. Return None if file cannot be loaded.

    OUTPUTS:
        channels: channels header from Neo raw output class
        reader: neo raw output class
        block_neo_file: block from the neo file
    """
    try:
        if file_ext.upper() == ".ABF":
            reader = neo.AxonIO(full_filepath)
        elif file_ext.upper() in [".AXGX", ".AXGD"]:
            reader = neo.AxographIO(full_filepath)
        elif file_ext.upper() == ".WCP":
            reader = neo.WinWcpIO(full_filepath)
        elif file_ext.upper() == ".EDR":
            reader = neo.WinEdrIO(full_filepath)
        else:
            utils.show_messagebox("Cannot Determine filetype",
                                  "Cannot determine filetype. Currently supported filetypes are:\n"
                                  ".abf, .axgx, .wcp, .edr")
            return None, None, None
    except:
        utils.show_messagebox("Neo Load Error", "Could not load file. Check that the "
                                                "sampling rate is identical for all records "
                                                "and that read permission is granted.")
        return None, None, None

    block_neo_file = reader.read_block(signal_group_mode="split-all")  # if grouped, grouped signals go to first index destroying the order specified in reader.headers["signal_channels"]
    channels = reader.header["signal_channels"]

    return channels, reader, block_neo_file

def get_channel_data_info(cfgs, channels, reader):
    """
    Load channels from the raw neo file.
    Currently EE can handle only two channel types. If more are present, user is given option to select which channels to load.
    """
    if cfgs.file_load_options["select_channels_to_load"]["on"]:
        return get_users_default_channels(cfgs, reader)
    else:
        return get_default_channels(channels, reader)

def get_users_default_channels(cfgs, reader):
    """
    Be careful about None vs. 0 here, check explicitly for None
    """
    channel_1_idx = cfgs.file_load_options["select_channels_to_load"]["channel_1_idx"]
    channel_2_idx = cfgs.file_load_options["select_channels_to_load"]["channel_2_idx"]

    try:
        channel_1 = reader.header["signal_channels"][channel_1_idx]
        channel_2 = None if channel_2_idx is None else reader.header["signal_channels"][channel_2_idx]

    except:
        utils.show_messagebox("Input Error",
                              "When selecting channels to load in 'File' > 'Load Options', "
                              "ensure the channels exist in the file.")
        return None, None, None, None

    return channel_1, channel_1_idx, channel_2, channel_2_idx

def get_default_channels(channels, reader):
    """
    """
    channel_2 = channel_2_idx = None
    num_channels = len(channels)

    if num_channels > 2:
        channel_1_idx, channel_2_idx, channel_1, channel_2 = utils.get_channels_from_user_input(reader)

    elif num_channels in [1, 2]:
        channel_1_idx = 0
        channel_1 = reader.header["signal_channels"][channel_1_idx]

        if num_channels == 2:
            channel_2_idx = 1
            channel_2 = reader.header["signal_channels"][channel_2_idx]

    return channel_1, channel_1_idx, channel_2, channel_2_idx


def get_channel_type(channel, cfgs):
    """
    Find the channel type based on it's saved name or units.

    Often the channel name reflects the input number of the amplifier e.g. IN0 and is no use.
    In this case the units is used.

    TODO: depreciated using channel type to identify channel as too vague. Now specify from
    units type to clearly force units to pA or mV.
    """
    channel_units = channel[4].strip()

    if channel_units == "mV":
        channel_type = "Vm"
    elif channel_units == "pA":
        channel_type = "Im"
    elif channel_units in ["fA", "nA", "uA", "mA", "A", "pV", "nV", "uV", "V"]:
        channel_units, channel_type = process_non_default_channel_units(channel_units, cfgs)
        if channel_units is None:
            return None, None
    else:
        utils.show_messagebox("Type Error",
                              "Cannot determine recording type. Please contact support@easyelectrophysiology.com")
        return None, None
    return channel_type, channel_units

def process_non_default_channel_units(channel_units, cfgs):
    """
    For some files the channel is specifier at the amplifier as 'A' generically. This is taken as the units for
    the data even though typically they are always recorded in pA. If such a file is encountered and default behaviour
    is not specified, prompt the user to set defaults. Otherwise, load the file as per the defaults.

    Data are converted at the Data class level depending on the channel_units type, so changing units to pA here means they
    will not be converted later.
    """
    if channel_units in ["fA", "nA", "uA", "mA", "A"]:  # TODO: bit verbose but explicit and removes dependency on calling function
        channel_type = "Im"
    elif channel_units in ["pV", "nV", "uV", "V"]:
        channel_type = "Vm"

    if channel_type == "Im" and cfgs.file_load_options["default_im_units"]["on"]:
        channel_units = "pA" if cfgs.file_load_options["default_im_units"]["assume_pa"] else cfgs.file_load_options["default_im_units"]["pa_unit_to_convert"]

    elif channel_type == "Vm" and cfgs.file_load_options["default_vm_units"]["on"]:
        channel_units = "mV" if cfgs.file_load_options["default_vm_units"]["assume_mv"] else cfgs.file_load_options["default_vm_units"]["mv_unit_to_convert"]

    else:
        expected_units = "pA" if channel_type == "Im" else "mV"
        utils.show_messagebox("Channel Units Error",
                              "The units in the file header are {0} but are expected to be {1}. Please specify default "
                              "file loading options in 'File' > 'File Loading Options' > Specify Default Unit Handling'.".format(channel_units,
                                                                                                                                 expected_units))
        channel_units = channel_type = None

    return channel_units, channel_type

# ----------------------------------------------------------------------------------------------------------------------------------------------------
# Data Class
# ----------------------------------------------------------------------------------------------------------------------------------------------------

class ImportData:
    """
    Extract Vm, Im and time arrays from Neo object.
    Note that depending on the software which recorded the data, time may increase cumulatively across records.
    Data is kept as 64-bit as is the usually fastest datatype to compute with numpy.

    Time offset:  For some file formats a slight offset is added to the time, meaning it will start at a non-zero value.
                  if this is present in the data, self.time_offset will be set to the offset and data changed at the model level.
                  cannot wrap dialog to this class or will throw pickle error on deepcopy at model level.

    """
    def __init__(self, block_neo_file, num_chans, cfgs,
                 channel_1_type, channel_1_units, channel_1_idx,
                 channel_2_type, channel_2_units, channel_2_idx):

        self.load_setting = cfgs.file_load_options["force_load_options"]
        self.num_recs = len(block_neo_file.segments)
        self.num_samples = len(block_neo_file.segments[0].analogsignals[0])
        self.fs = block_neo_file.segments[0].analogsignals[0].sampling_rate.magnitude  # strip quantities
        self.ts = block_neo_file.segments[0].analogsignals[0].sampling_period.magnitude
        self.time_units = str(block_neo_file.segments[0].t_start).split(" ")[1]
        self.vm_array = np.zeros((self.num_recs,
                                  self.num_samples))
        self.im_array = np.zeros((self.num_recs,
                                  self.num_samples))  # empty must be zero, if empty or nan cannot be properly plot by pyqtgraphs in the one-channel case
        self.time_array = np.zeros((self.num_recs,
                                    self.num_samples))
        self.num_data_channels = num_chans
        self.time_offset = False                      # in rare cases, some setups will add a tiny offset to time so it does not start at zero
        self.vm_units = None
        self.im_units = None
        self.t_start = None                           # start time (first record)
        self.t_stop = None                            # end time (final record)
        self.channel_1_type = channel_1_type
        self.channel_2_type = channel_2_type
        self.recording_type = None

        if self.load_setting is None and channel_1_type == "Vm" or \
                self.load_setting == "current_clamp":
            self.vm_array = self.extract_data_from_array(channel_1_idx, block_neo_file)
            self.vm_units = channel_1_units
            self.recording_type = "current_clamp"

        elif self.load_setting is None and channel_1_type == "Im" or \
                self.load_setting == "voltage_clamp":
            self.im_array = self.extract_data_from_array(channel_1_idx, block_neo_file)
            self.im_units = channel_1_units
            if self.num_recs == 1:
                self.recording_type = "voltage_clamp_1_record"
            else:
                self.recording_type = "voltage_clamp_multi_record"

        if channel_2_idx is not None:
            if self.load_setting is None and channel_2_type == "Vm" or \
                    self.load_setting == "voltage_clamp":
                self.vm_array = self.extract_data_from_array(channel_2_idx, block_neo_file)
                self.vm_units = channel_2_units

            elif self.load_setting is None and channel_2_type == "Im" or \
                    self.load_setting == "current_clamp":
                self.im_array = self.extract_data_from_array(channel_2_idx, block_neo_file)
                self.im_units = channel_2_units

        self.time_array, self.t_start, self.t_stop = self.extract_time_array(block_neo_file)
        self.check_and_clean_data()
        return

    def check_and_clean_data(self):
        """
        Convert V to mV,
        nA to pA,
        ms to s
        """
        conversion_to_pa_table = core_analysis_methods.get_conversion_to_pa_table()
        conversion_to_mv_table = core_analysis_methods.get_conversion_to_mv_table()

        if self.im_units and self.im_units != "pA":
            self.im_array *= conversion_to_pa_table[self.im_units]
            self.im_units = "pA"

        if self.vm_units and self.vm_units != "mV":
            self.vm_array *= conversion_to_mv_table[self.vm_units]
            self.vm_units = "mV"

        if self.time_units == "ms":
            self.t_start /= 1000
            self.t_stop /= 1000
            self.time_array /= 1000
            self.time_units = "s"

        if self.t_start != 0:
            self.time_offset = np.array(self.t_start)

    def extract_time_array(self, block_neo_file):
        """
        """
        time_array = utils.np_empty_nan((self.num_recs,
                                         self.num_samples))
        for rec in range(self.num_recs):
            time_ = core_analysis_methods.generate_time_array(block_neo_file.segments[rec].t_start.magnitude,
                                                              block_neo_file.segments[rec].t_stop.magnitude,
                                                              self.num_samples,
                                                              self.ts)

            time_array[rec, :] = time_.squeeze()

        t_start = float(block_neo_file.segments[0].t_start)                   # get first and very last time point in case data needs cutting into records (cut_up_data() in data model)
        t_stop = float(block_neo_file.segments[self.num_recs - 1].t_stop)     # convert to float to remove units formatting, zero idx

        return time_array, t_start, t_stop

    def extract_data_from_array(self, data_idx, block_neo_file):
        """
        extract Im or Vm from neo model (depending on analogsignal idx)
        """
        array = utils.np_empty_nan((self.num_recs,
                                    self.num_samples))
        for rec in range(self.num_recs):
            data = block_neo_file.segments[rec].analogsignals[data_idx].magnitude
            array[rec, :] = data.squeeze()

        return array



